using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Malware.MDKServices;
using MDK.Build.DocumentAnalysis;
using MDK.Build.Solution;

namespace MDK.Build.Composers.Default
{
    /// <summary>
    /// The generator used to produce the final script after all the rest of the build operation is complete.
    /// </summary>
    public class DefaultComposer : ScriptComposer
    {
        /// <summary>
        /// Generates a final script of the given document. This document has been generated by the build process and
        /// contains the entire script in syntax tree form.
        /// </summary>
        /// <param name="composition"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        public override async Task<string> GenerateAsync(ProgramComposition composition, MDKProjectProperties config)
        {
            var analyzer = new DocumentAnalyzer();
            var result = await analyzer.AnalyzeAsync(composition.Document);
            var buffer = new StringBuilder();

            var programContent = string.Join("\n", result.Parts.OfType<ProgramScriptPart>().Select(p => p.GenerateContent()));
            buffer.Append(programContent);
            buffer.Append("\n");

            var extensionContent = string.Join("\n", result.Parts.OfType<ExtensionScriptPart>().Select(p => p.GenerateContent()));

            if (!string.IsNullOrWhiteSpace(extensionContent))
            {
                // Extension classes are made possible by forcefully ending Space Engineer's wrapping Program class
                // and removing the final ending brace of the last extension class to let Space Engineers close it 
                // for itself.

                // Close off the Program class
                buffer.Append("}\n");
                buffer.Append(extensionContent);
                // Remove the ending brace of the last extension class
                var index = FindEndBrace(buffer);
                if (index >= 0)
                    buffer.Length = index;
            }

            return TrimPointlessWhitespace(buffer.ToString());
        }

        int FindEndBrace(StringBuilder buffer)
        {
            for (var i = buffer.Length - 1; i >= 0; i--)
            {
                var ch = buffer[i];
                if (char.IsWhiteSpace(ch) || ch != '}')
                    continue;
                return i;
            }

            return -1;
        }
    }
}
