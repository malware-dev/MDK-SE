using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Malware.MDKServices;
using MDK.Build.Annotations;
using MDK.Build.DocumentAnalysis;
using MDK.Build.Solution;

namespace MDK.Build.Composers.Minifying
{
    /// <summary>
    /// A composer which attempts to fit the given script into as small a space as possible.
    /// </summary>
    public class MinifyingComposer : ScriptComposer
    {
        /// <summary>
        /// Generates a final script of the given document. This document has been generated by the build process and
        /// contains the entire script in syntax tree form.
        /// </summary>
        /// <param name="composition"></param>
        /// <param name="config"></param>
        /// <returns></returns>
        public override async Task<string> GenerateAsync(ProgramComposition composition, MDKProjectProperties config)
        {
            //var dumper = new PreserveDebugDumper(@"e:\dump0.txt");
            //dumper.Visit(await composition.Document.GetSyntaxRootAsync());

            var simplifier = new CodeSimplifier();
            composition = await simplifier.ProcessAsync(composition, config);
            //dumper = new PreserveDebugDumper(@"e:\dump1.txt");
            //dumper.Visit(await composition.Document.GetSyntaxRootAsync());

            var renamer = new SymbolRenamer();
            composition = await renamer.ProcessAsync(composition, config);
            //dumper = new PreserveDebugDumper(@"e:\dump2.txt");
            //dumper.Visit(await composition.Document.GetSyntaxRootAsync());

            var compactor = new WhitespaceCompactor();
            composition = await compactor.ProcessAsync(composition, config);
            //dumper = new PreserveDebugDumper(@"e:\dump3.txt");
            //dumper.Visit(await composition.Document.GetSyntaxRootAsync());

            var lineWrapper = new LineWrapper();
            composition = await lineWrapper.ProcessAsync(composition, config);
            //dumper = new PreserveDebugDumper(@"e:\dump4.txt");
            //dumper.Visit(await composition.Document.GetSyntaxRootAsync());

            return await GenerateScriptAsync(composition);
        }

        async Task<string> GenerateScriptAsync(ProgramComposition composition)
        {
            var root = composition.RootNode;
            composition = await composition.WithNewDocumentRootAsync(root);
            var analyzer = new DocumentAnalyzer();
            var result = await analyzer.AnalyzeAsync(composition.Document);
            var buffer = new StringBuilder();

            var programContent = string.Join("", result.Parts.OfType<ProgramScriptPart>().Select(p => p.GenerateContent()));
            buffer.Append(programContent);
            var extensionContent = string.Join("", result.Parts.OfType<ExtensionScriptPart>().Select(p => p.GenerateContent()));
            if (!string.IsNullOrWhiteSpace(extensionContent))
            {
                // Extension classes are made possible by forcefully ending Space Engineer's wrapping Program class
                // and removing the final ending brace of the last extension class to let Space Engineers close it 
                // for itself.

                // Close off the Program class. Unfortunately we do need a newline because the whitespace compactor 
                // can't properly deal with the separation.
                buffer.Append("\n}");
                buffer.Append(extensionContent);
                // Remove the ending brace of the last extension class
                var index = FindEndBrace(buffer);
                if (index >= 0)
                    buffer.Length = index;
            }

            return TrimPointlessWhitespace(buffer.ToString());
        }

        int FindEndBrace(StringBuilder buffer)
        {
            for (var i = buffer.Length - 1; i >= 0; i--)
            {
                var ch = buffer[i];
                if (char.IsWhiteSpace(ch) || ch != '}')
                    continue;
                return i;
            }

            return -1;
        }
    }
}
